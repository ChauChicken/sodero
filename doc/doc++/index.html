<HTML>
<HEAD>
   <TITLE>Table of Contents</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.3.15">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H1>Tabla de Contenidos</H1>
<H2>Funciones</H2>
<UL>
<LI><A HREF="handler_interrupcion.html">(*handler_interrupcion)</A> <I> Representa la funcion asociada a la tarea que atiende a una interrupcion</I>
<LI><A HREF="handler_irq.html">(*handler_irq)</A> <I> Representa la funcion asociada a la tarea que atiende a un IRQ</I>
<LI><A HREF="handler_tarea.html">(*handler_tarea)</A> <I> Definicion de tipo que representa un puntero a funcion (utilizada para setear el EIP de un TSS con el valor de la tarea que tendra dicho TSS) Nota: Se utiliza el seteo del EIP con este valor siempre y cuando no sea un proceso de usuario</I>
<LI><A HREF="puntero_funcion.html">(*puntero_funcion)</A> <I> Tipo de dato representativo de un puntero a funcion</I>
<LI><A HREF="a_mayusculas.html">a_mayusculas</A> <I> a_mayusculas: Funcion que se encarga de pasar una cadena a mayusculas  </I>
<LI><A HREF="a_minusculas.html">a_minusculas</A> <I> a_minusculas: Funcion que se encarga de pasar una cadena a minusculas  </I>
<LI><A HREF="abrir.html">abrir</A> <I> sys_abrir: syscall encargada de abrir un archivo</I>
<LI><A HREF="actualizar_cursor.html">actualizar_cursor</A> <I> actualizar_cursor: actualiza la posicion del cursor en base a las coordenadas actuales</I>
<LI><A HREF="admin_procesos.html">admin_procesos</A> <I> Esta funcion representa a la tarea del scheduler</I>
<LI><A HREF="agregar.html">agregar</A> <I> Funcion que agrega un proceso en la cola de listos</I>
<LI><A HREF="agregar_caracter.html">agregar_caracter</A> <I> agregar_caracter: Esta funcion agrega un caracter al buffer de teclado e incrementa el indice de escritura siempre y cuando no pase el limite de  caracteres a poder ser leidos por el buffer</I>
<LI><A HREF="align_exception.html">align_exception</A> <I> Handler para la interrupcion numero 17</I>
<LI><A HREF="alocar.html">alocar</A> <I> alocar: reserva espacio en memoria para una determinada cantidad de bytes </I>
<LI><A HREF="apagar_motor.html">apagar_motor</A> <I> Apaga el motor de la disquetera</I>
<LI><A HREF="beep.html">beep</A> <I> beep: Produce un sonido </I>
<LI><A HREF="borrar_caracter.html">borrar_caracter</A> <I> borrar_caracter: borra un caracter de pantalla y actualiza el cursor</I>
<LI><A HREF="bound_exception.html">bound_exception</A> <I> Handler para la interrupcion numero 5</I>
<LI><A HREF="break_exception.html">break_exception</A> <I> Handler para la interrupcion numero 3</I>
<LI><A HREF="btoa.html">btoa</A> <I> btoa: transforma un byte en ascii </I>
<LI><A HREF="btoh.html">btoh</A> <I> btoh: transforma un byte en ascii ( formato hexa ) </I>
<LI><A HREF="bucle_infinito.html">bucle_infinito</A> <I> Funcion de test que simula un bucle infinito desde assembler</I>
<LI><A HREF="buscar_entrada.html">buscar_entrada</A> <I> buscar_entrada: busca una entrada dentro del root directory </I>
<LI><A HREF="cargar_BPB.html">cargar_BPB</A> <I> cargar_BPB: Carga el BIOS Parameter Block en memoria (en una variable global) </I>
<LI><A HREF="cargar_fat.html">cargar_fat</A> <I> cargar_fat: Carga la tabla FAT en memoria (en una variable global)  </I>
<LI><A HREF="cargar_idt.html">cargar_idt</A> <I> Funcion que realiza un 'lidt' (Load IDT) desde assembler, si bien el header esta declarado en C, la implementacion de dicha funcion esta echa en assembler</I>
<LI><A HREF="cargar_tr.html">cargar_tr</A> <I> Esta funcion realiza el ltr (Load TR, Cargar Registro de Tarea) Se invoca una unica vez en la ejecucion del Sistema operativo para setear el TR con la tarea de sistema</I>
<LI><A HREF="cluster_a_lba.2.html">cluster_a_lba</A> <I> cluster_a_lba: transforma un cluster (direccion logica de FAT) a un sector LBA (direccion logica de sector) </I>
<LI><A HREF="co_cpu_overrun.2.html">co_cpu_overrun</A> <I> Handler para la excepcion numero 9</I>
<LI><A HREF="comparar_cadenas.html">comparar_cadenas</A> <I> comparar_cadenas: compara dos cadenas </I>
<LI><A HREF="comparar_nombres.html">comparar_nombres</A> <I> comparar_nombres: Compara un nombre de archivo ingresado con otro de la  entrada del root directory</I>
<LI><A HREF="configurar_fdc.html">configurar_fdc</A> <I> configurar_fdc: comando configure del FDC, debido a que los parametros por default estan bien, no hace falta ejecutarlo</I>
<LI><A HREF="copiar_memoria.html">copiar_memoria</A> <I> Metodo analogo al memcpy, en realidad deberia ir en otro lado</I>
<LI><A HREF="crear_tarea.html">crear_tarea</A> <I> Funcion que saca un proceso de la cola de listos</I>
<LI><A HREF="ctoi.html">ctoi</A> <I> ctoi: transforma una cadena en entero </I>
<LI><A HREF="debug_exception.html">debug_exception</A> <I> Handler para la interrupcion numero 1</I>
<LI><A HREF="detectar_disquetera.html">detectar_disquetera</A> <I> detectar_disquetera: detecta el tipo de disquetera que tiene el equipo Simplemente lo informa por pantalla</I>
<LI><A HREF="detectar_ide.html">detectar_ide</A> <I> detectar_ide: Funcion que se encarga de detecta la existacia de un  determinado dispositivo IDE</I>
<LI><A HREF="disquetera_handler.2.html">disquetera_handler</A> <I> disquetera_handler: Handler de la IRQ6</I>
<LI><A HREF="div_cero.2.html">div_cero</A> <I> Handler para la excepcion numero 0</I>
<LI><A HREF="dump_BPB.html">dump_BPB</A> <I> Muestra el contenido del BPB</I>
<LI><A HREF="dump_cola_ready.html">dump_cola_ready</A> <I> Funcion que realiza un dump de la cola de listos</I>
<LI><A HREF="dword_fault.html">dword_fault</A> <I> Handler para la interrupcion numero 8</I>
<LI><A HREF="ejecutar.html">ejecutar</A> <I> ejecutar: API que se utiliza para ejecutar un proceso a partir de un archivo Se llama a la System Call sys_ejecutar</I>
<LI><A HREF="encender_motor.html">encender_motor</A> <I> enciende el motor de la disquetera</I>
<LI><A HREF="escribir_byte.html">escribir_byte</A> <I> escribir_byte: envia un byte al registro FIFO del FDC Funcion echa en base al pseudo-codigo del manual del 82077AA de Intel  </I>
<LI><A HREF="especificar_fdc.html">especificar_fdc</A> <I>  especificar_fdc: Implementacion del comando specify del FDC  <pre> Valores de los argumentos: byte0: 0x03 (duro) byte1:  +-----+-----+-----+-----+-----+-----+-----+-----+ | SR3 | SR2 | SR1 | SR0 | HU3 | HU2 | HU1 | HU0 | +-----+-----+-----+-----+-----+-----+-----+-----+ byte 2: +-----+-----+-----+-----+-----+-----+-----+-----+ | HL6 | HL5 | HL4 | HL3 | HL2 | HL1 | HL0 | DMA | +-----+-----+-----+-----+-----+-----+-----+-----+ SR: (Step Rate Time) tiempo comprendido entre dos impulsos consecutivos  de la senial que mueve el motor paso a paso</I>
<LI><A HREF="esperar_interrupcion.html">esperar_interrupcion</A> <I> esperar_interrupcion: espera que se dispare la IRQ</I>
<LI><A HREF="esperar_pid.html">esperar_pid</A> <I> esperar_pid: API que se utiliza para que un proceso espere que termine otro y luego recien continuar su ejecucion</I>
<LI><A HREF="estado_interrupcion.html">estado_interrupcion</A> <I> estado_interrupcion: implementa el comando del FDC que consulta el estado (condiciones de fin, etc) de la ultima interrupcion que se disparo</I>
<LI><A HREF="get_cs.html">get_cs</A> <I> Devuelve el Segmento de Pila</I>
<LI><A HREF="get_ds.html">get_ds</A> <I> Devuelve el El segmento de Datos</I>
<LI><A HREF="get_es.html">get_es</A> <I> Devuelve el Stack Segment</I>
<LI><A HREF="get_esp.html">get_esp</A> <I> Devuelve el Puntero de Pila (ESP)</I>
<LI><A HREF="get_fs.html">get_fs</A> <I> Devuelve el Segmento F</I>
<LI><A HREF="get_gs.html">get_gs</A> <I> Devuelve el Segmento G</I>
<LI><A HREF="get_ss.html">get_ss</A> <I> Devuelve el Stack Segment</I>
<LI><A HREF="getc.html">getc</A> <I> getc: obtiene un caracter leyendo del teclado ( a travez de la sys call ) </I>
<LI><A HREF="handler.3.html">handler</A> <I> Funcion generica para manejar las interrupciones, implementada en aquellas interrupciones donde no hay un handler especifico para manejarlas</I>
<LI><A HREF="imprimir.2.html">imprimir</A> <I> imprimir: Imprime una cadena por pantalla, recibiendo argumentos variables, en forma analoga a la funcion de biblioteca de C printf()</I>
<LI><A HREF="imprimir_byte.html">imprimir_byte</A> <I> imprimir_byte: Imprime un byte (8 bits) por pantalla</I>
<LI><A HREF="imprimir_byte_hexa.2.html">imprimir_byte_hexa</A> <I> imprimir_byte_hexa: Imprime un byte (8 bits) en base 16 por pantalla</I>
<LI><A HREF="imprimir_cadena.2.html">imprimir_cadena</A> <I> imprimir_cadena: Imprime una cadena por pantalla</I>
<LI><A HREF="imprimir_entero.2.html">imprimir_entero</A> <I> imprimir_entero: Imprime un entero o un doble word (32 bits) por pantalla </I>
<LI><A HREF="imprimir_entrada.html">imprimir_entrada</A> <I> imprimir_entrada: Funcion privada al modulo que formatea una entrada  directorio para mostrarla bien</I>
<LI><A HREF="imprimir_hexa.2.html">imprimir_hexa</A> <I> imprimir_hexa: Imprime un entero o doble word (32 bits) en base 16 por  pantalla</I>
<LI><A HREF="imprimir_word.html">imprimir_word</A> <I> imprimir_word: Imprime un word (16 bits) por pantalla </I>
<LI><A HREF="imprimir_word_hexa.2.html">imprimir_word_hexa</A> <I> imprimir_word_hexa: Imprime un word (16 bits) en base 16 por pantalla</I>
<LI><A HREF="inb.html">inb</A> <I> inb: funcion que lee un byte de un puerto determinado (implementada en  assembler @see puertos</I>
<LI><A HREF="incrementar_coordenadas.html">incrementar_coordenadas</A> <I> incrementar_coordenadas: Funcion privada al modulo que incrementa las  coordenadas por cada caracter que imprime</I>
<LI><A HREF="ingresar_cadena.html">ingresar_cadena</A> <I> ingresar_cadena: analoga a la funcion gets() de UNIX </I>
<LI><A HREF="inicializa_fat.2.html">inicializa_fat</A> <I> inicializa_fat: Setea el BPB y la FAT en NULL para que actuen como flags  (asi se cargan una unica vez)</I>
<LI><A HREF="inicializa_teclado.html">inicializa_teclado</A> <I> inicializa_teclado: Funcion utilizada para inicializar el teclado</I>
<LI><A HREF="inicializar_fdc.html">inicializar_fdc</A> <I> inicializar_fdc: resetea el controlador de disquete y lo inicializa con los valores necesarios</I>
<LI><A HREF="inicializar_ide.html">inicializar_ide</A> <I> inicializar_ide: Funcion que se encarga de inicializar los dispositivos  IDE</I>
<LI><A HREF="inicializar_tss.2.html">inicializar_tss</A> <I> Pone en cero a toda la TSS que recibe como parametro  </I>
<LI><A HREF="init.html">init</A> <I> Funcion init</I>
<LI><A HREF="inw.html">inw</A> <I> inw: funcion que lee una palabea de un puerto determinado (implementada en  assembler @see puertos</I>
<LI><A HREF="ir_a_tarea.html">ir_a_tarea</A> <I> Realiza un far jmp a la tarea referenciada por el selector que recibe como argumento</I>
<LI><A HREF="irq0_handler_asm.html">irq0_handler_asm</A> <I> Funcion que representa a la tarea de la IRQ 0</I>
<LI><A HREF="irq10_handler.html">irq10_handler</A> <I> Funcion que atiende a la IRQ 10</I>
<LI><A HREF="irq10_handler_asm.html">irq10_handler_asm</A> <I> Funcion que representa a la tarea de la IRQ 12</I>
<LI><A HREF="irq11_handler.2.html">irq11_handler</A> <I> Handler para la IRQ numero 11 </I>
<LI><A HREF="irq11_handler_asm.html">irq11_handler_asm</A> <I> Funcion que representa a la tarea de la IRQ 11</I>
<LI><A HREF="irq12_handler.2.html">irq12_handler</A> <I> Handler para la IRQ numero 12 </I>
<LI><A HREF="irq12_handler_asm.html">irq12_handler_asm</A> <I> Funcion que representa a la tarea de la IRQ 12</I>
<LI><A HREF="irq13_handler.2.html">irq13_handler</A> <I> Handler para la IRQ numero 13 </I>
<LI><A HREF="irq13_handler_asm.html">irq13_handler_asm</A> <I> Funcion que representa a la tarea de la IRQ 13</I>
<LI><A HREF="irq14_handler.html">irq14_handler</A> <I> Funcion que atiende a la IRQ 14</I>
<LI><A HREF="irq14_handler_asm.html">irq14_handler_asm</A> <I> Funcion que representa a la tarea de la IRQ 14</I>
<LI><A HREF="irq15_handler.html">irq15_handler</A> <I> Funcion que atiende a la IRQ 15</I>
<LI><A HREF="irq15_handler_asm.html">irq15_handler_asm</A> <I> Funcion que representa a la tarea de la IRQ 15</I>
<LI><A HREF="irq1_handler.html">irq1_handler</A> <I> Funcion que atiende a la IRQ 1</I>
<LI><A HREF="irq1_handler_asm.html">irq1_handler_asm</A> <I> Funcion que representa a la tarea de la IRQ 1</I>
<LI><A HREF="irq2_handler.html">irq2_handler</A> <I> Funcion que atiende a la IRQ 2</I>
<LI><A HREF="irq2_handler_asm.html">irq2_handler_asm</A> <I> Funcion que representa a la tarea de la IRQ 2</I>
<LI><A HREF="irq3_handler.html">irq3_handler</A> <I> Funcion que atiende a la IRQ 3</I>
<LI><A HREF="irq3_handler_asm.html">irq3_handler_asm</A> <I> Funcion que representa a la tarea de la IRQ 3</I>
<LI><A HREF="irq4_handler.html">irq4_handler</A> <I> Funcion que atiende a la IRQ 4</I>
<LI><A HREF="irq4_handler_asm.html">irq4_handler_asm</A> <I> Funcion que representa a la tarea de la IRQ 4</I>
<LI><A HREF="irq5_handler.2.html">irq5_handler</A> <I> Handler para la IRQ numero 5 </I>
<LI><A HREF="irq5_handler_asm.html">irq5_handler_asm</A> <I> Funcion que representa a la tarea de la IRQ 5</I>
<LI><A HREF="irq6_handler.html">irq6_handler</A> <I> Funcion que atiende a la IRQ 6</I>
<LI><A HREF="irq6_handler_asm.html">irq6_handler_asm</A> <I> Funcion que representa a la tarea de la IRQ 7</I>
<LI><A HREF="irq7_handler.html">irq7_handler</A> <I> Funcion que atiende a la IRQ 7</I>
<LI><A HREF="irq7_handler_asm.html">irq7_handler_asm</A> <I> Funcion que representa a la tarea de la IRQ 7</I>
<LI><A HREF="irq8_handler.2.html">irq8_handler</A> <I> Handler para la IRQ numero 8 </I>
<LI><A HREF="irq8_handler_asm.html">irq8_handler_asm</A> <I> Funcion que representa a la tarea de la IRQ 8</I>
<LI><A HREF="irq9_handler.html">irq9_handler</A> <I> Funcion que atiende a la IRQ 9</I>
<LI><A HREF="irq9_handler_asm.html">irq9_handler_asm</A> <I> Funcion que representa a la tarea de la IRQ 9</I>
<LI><A HREF="itoa.html">itoa</A> <I> itoa: transforma un entero en ascii </I>
<LI><A HREF="itoh.html">itoh</A> <I> itoh: transforma un entero en ascii ( formato hexa ) </I>
<LI><A HREF="leer.html">leer</A> <I> sys_abrir: syscall encargada de leer sobre un archivo</I>
<LI><A HREF="leer_archivo.html">leer_archivo</A> <I> leer_archivo: lee desde un file descriptor, que representa un archivo,  analoga a la funcion read de UNIX </I>
<LI><A HREF="leer_byte.2.html">leer_byte</A> <I> leer_byte: leee una palabra desde el registro FIFO del FDC unicamente  cuando los bits RQM y DIO del MSR estan en uno</I>
<LI><A HREF="leer_sector.2.html">leer_sector</A> <I> leer_sector: Lee un sector de disco, recibiendo como argumentos cabeza,  pista y sector</I>
<LI><A HREF="leer_sector_logico.2.html">leer_sector_logico</A> <I> leer_sector_logico: lee un sector logico del disquete  </I>
<LI><A HREF="liberar.html">liberar</A> <I> liberar: libera una posicion de memoria </I>
<LI><A HREF="llamar_int.html">llamar_int</A> <I> Funcion de test utilizada para invocar a una interrupcion</I>
<LI><A HREF="llamar_sys_call.html">llamar_sys_call</A> <I> llamar_sys_call: funcion que centraliza la llamada a una system call su implementacion esta realizada en assembler (@see usuario</I>
<LI><A HREF="longitud_cadena.2.html">longitud_cadena</A> <I> longitud_cadena: Devuelve la longitud de una cadena (teniendo en cuenta  que el caracter de finalizacion de una cadena sera el  caracter 0, ascii 48)</I>
<LI><A HREF="machine_exception.2.html">machine_exception</A> <I> Handler para la excepcion numero 18</I>
<LI><A HREF="main.7.html">main</A> <I> main: proceso que alterna el modo de apropiacion del microprocesador a traves de la api correspondiente (@see xchg_aprop</I>
<LI><A HREF="matar.html">matar</A> <I> matar: API que se utiliza para terminar o finalizar un proceso que se  encuentre activo en el sistema</I>
<LI><A HREF="math_fault.html">math_fault</A> <I> Handler para la interrupcion numero 16</I>
<LI><A HREF="nm2_interrupt.2.html">nm2_interrupt</A> <I> Handler para la excepcion numero 2</I>
<LI><A HREF="no_math_exception.2.html">no_math_exception</A> <I> Handler para la excepcion numero 7</I>
<LI><A HREF="nueva_linea.html">nueva_linea</A> <I> nueva_linea: Imprime una nueva linea</I>
<LI><A HREF="nuevonodo.2.html">nuevonodo</A> <I> Funcion que crea un nuevo nodo en el uso de colas</I>
<LI><A HREF="obtener_caracter_teclado.html">obtener_caracter_teclado</A> <I> obtener_caracter_teclado: Esta funcion obtiene un caracter del buffer de  teclado</I>
<LI><A HREF="opcode_exception.2.html">opcode_exception</A> <I> Handler para la excepcion numero 6</I>
<LI><A HREF="outb.html">outb</A> <I> outb: funcion que escribe un byte en un puerto determinado (implementada en assembler @see puertos</I>
<LI><A HREF="outw.html">outw</A> <I> outw: funcion que escribe una palabra en un puerto determinado (implementada en assembler @see puertos</I>
<LI><A HREF="overflow_exception.2.html">overflow_exception</A> <I> Handler para la excepcion numero 4</I>
<LI><A HREF="parsear_argumentos.html">parsear_argumentos</A> <I> parsear_argumentos: Funcion que se encarga de parsear los argumentos, o sea de separar cuando encuentra un espacio (' ') los argumentos y asignarlos al array de argumantos</I>
<LI><A HREF="pausa.html">pausa</A> <I> pausa: API que se utiliza para relizar una pausa en un proceso en ejecucion</I>
<LI><A HREF="pf_exception.2.html">pf_exception</A> <I> Handler para la excepcion numero 14</I>
<LI><A HREF="present_exception.2.html">present_exception</A> <I> Handler para la excepcion numero 11</I>
<LI><A HREF="protection_exception.2.html">protection_exception</A> <I> Handler para la excepcion numero 13</I>
<LI><A HREF="ps.html">ps</A> <I> ps: api que realiza la llamada a la system call que muestra los procesos  </I>
<LI><A HREF="raton_handler.html">raton_handler</A> <I> raton_habler: funcion que controla el movimiento del raton atendiendo la  irq que el dispositivo genera (aun no implementada)  </I>
<LI><A HREF="reboot.html">reboot</A> <I> reboot: api que realiza la llamada a la system call que resetea la PC  </I>
<LI><A HREF="recalibrar.html">recalibrar</A> <I> recalibrar: ejecuta el comando recalibrar del FDC, el cual posiciona la cabeza lectora en la pista cero</I>
<LI><A HREF="reserved_exception.2.html">reserved_exception</A> <I> Handler para la excepcion numero 15</I>
<LI><A HREF="sacar.html">sacar</A> <I> Funcion que saca un proceso de la cola de listos</I>
<LI><A HREF="salir.html">salir</A> <I> salir: API que se utiliza para que termine o finalice el proceso actual</I>
<LI><A HREF="scroll.html">scroll</A> <I> scroll: Desplaza la pantalla hacia arriba una linea</I>
<LI><A HREF="seek.html">seek</A> <I> seek: posiciona la cabeza lectora en una pista dada</I>
<LI><A HREF="setear_desc_seg.2.html">setear_desc_seg</A> <I> Setea la entrada en la GDT como un descriptor de segmento, pasado como  parametro como el tipo de segmento a setear, la base del segmento, el  descriptor donde setear los valores y tamanio o limite del segmento</I>
<LI><A HREF="setear_desc_tss.2.html">setear_desc_tss</A> <I> Setea la entrada  en la GDT como un descriptor de una tss, pasando como parametro como un descriptor de TSS, obteniendo los datos de la TSS, tambien recibida como parametro</I>
<LI><A HREF="setear_gate_int.html">setear_gate_int</A> <I> Funcion que setea una interrupcion para que sea ejecutada como un TRAP GATE</I>
<LI><A HREF="setear_interrupcion.html">setear_interrupcion</A> <I> Funcion que setea una interrupcion para que sea ejecutada como un TASK GATE</I>
<LI><A HREF="setear_interrupciones.html">setear_interrupciones</A> <I> Funcion que realiza el seteo de los handlers de interrupciones dentro de la IDT</I>
<LI><A HREF="setear_irq.html">setear_irq</A> <I> Funcion que setea una interrupcion para que sea ejecutada como un TASK GATE</I>
<LI><A HREF="setear_leds.html">setear_leds</A> <I> setear_leds: esta funcion se encargar de encender o apagar los leds del teclado segun corresponda</I>
<LI><A HREF="setear_memoria.html">setear_memoria</A> <I> setear_memoria: setea una posicion de memoria con un determinado valor </I>
<LI><A HREF="setear_siguiente_indice.2.html">setear_siguiente_indice</A> <I> Funcion que setea el siguiente indice de entrada en la GDT  </I>
<LI><A HREF="setear_tarea.2.html">setear_tarea</A> <I> Funcion que setea una TSS con los valores necesarios para realizar el context switch (segmentos, eflags, eip, etc)</I>
<LI><A HREF="setear_temporizador.html">setear_temporizador</A> <I> setear_temporizador: setea el chip del temporizador 8254 para que dispare  la irq0 en el menor tiempo posible</I>
<LI><A HREF="siguiente_indice_gdt.html">siguiente_indice_gdt</A> <I> Devuelve el siguiente indice a asignar en la GDT</I>
<LI><A HREF="silencio.html">silencio</A> <I> silencio: desactiva el parlante</I>
<LI><A HREF="sonido.html">sonido</A> <I> sonido: activa el parlante </I>
<LI><A HREF="stack_exception.html">stack_exception</A> <I> Handler para la interrupcion numero 12</I>
<LI><A HREF="sys_abrir.html">sys_abrir</A> <I> sys_abrir: syscall encargada de abrir un archivo</I>
<LI><A HREF="sys_alocar.html">sys_alocar</A> <I> sys_alocar: asigna un sector de memoria para leer/escribir en funcion del  algoritmo de alocacion de memoria (actualmente implementamos uno que  aloca incrementalmente)  </I>
<LI><A HREF="sys_ejecutar.html">sys_ejecutar</A> <I> sys_ejecutar: System call utilizada para ejecutar un proceso</I>
<LI><A HREF="sys_esperar_pid.html">sys_esperar_pid</A> <I> sys_esperar_pid: Recorre la cola de listos hasta que el pid del proceso con el cual fue llamada deje de existir en la Cola Listos o en ejecucion</I>
<LI><A HREF="sys_getc.html">sys_getc</A> <I> sys_getc: syscall que obtiene un caracter leido por teclado</I>
<LI><A HREF="sys_leer.html">sys_leer</A> <I> sys_abrir: syscall encargada de leer sobre un archivo</I>
<LI><A HREF="sys_listar_directorio.html">sys_listar_directorio</A> <I> sys_listar_directorio: leer el root directory para mostrar su contenido </I>
<LI><A HREF="sys_matar.html">sys_matar</A> <I> sys_matar: System call encargada de matar un proceso</I>
<LI><A HREF="sys_pausa.html">sys_pausa</A> <I> sys_pausa: System call encargada de realizar una pausa en el proceso en ejecucion en ese momento</I>
<LI><A HREF="sys_printc.html">sys_printc</A> <I> sys_printc: imprime un caracter en las coordenadas especificas  </I>
<LI><A HREF="sys_ps.html">sys_ps</A> <I> sys_ps: System Call que lista los procesos que se estan ejecutando en el sistema operativo en ese momento</I>
<LI><A HREF="sys_reboot.html">sys_reboot</A> <I> sys_reboot: handler de la system call que permite resetear la PC  </I>
<LI><A HREF="sys_salir.html">sys_salir</A> <I> sys_salir: System Call que se encarga de salir del (matar el) proceso actual</I>
<LI><A HREF="sys_setear_color.html">sys_setear_color</A> <I> Seteo de colores (para imprimir la salida)</I>
<LI><A HREF="sys_xchg_aprop.html">sys_xchg_aprop</A> <I> sys_xchg_aprop: handler de la system call que permite cambiar el modo de  apropiacion del microprocesador  </I>
<LI><A HREF="tabulador.html">tabulador</A> <I> tabulador: Imprime un TAB por pantalla</I>
<LI><A HREF="tarea_apagar_motor.html">tarea_apagar_motor</A> <I> Periodicamente apagara el motor de la disquetera</I>
<LI><A HREF="tarea_dummy.html">tarea_dummy</A> <I> Tarea oseosa que imprime su nombre y pid en un bucle</I>
<LI><A HREF="teclado_handler.html">teclado_handler</A> <I> teclado_handler: Funcion que representa a la tarea que se ejecuta cuando ocurre una interrupcion de teclado (IRQ1)</I>
<LI><A HREF="test_fat.html">test_fat</A> <I> test_fat: Funcion de prueba utilizada durante la etapa de desarrollo</I>
<LI><A HREF="timer_handler.html">timer_handler</A> <I> Esta funcion representa a la tarea del timer (IRQ 0)</I>
<LI><A HREF="tss_exception.html">tss_exception</A> <I> Handler para la interrupcion numero 10</I>
<LI><A HREF="ver_desc_seg.html">ver_desc_seg</A> <I> Funcion que realiza un dump de un descriptor de Segmento para conocer  sus valores a partir del Indice dentro de la GDT donde se encuentre este descriptor</I>
<LI><A HREF="ver_descriptor.html">ver_descriptor</A> <I> Funcion que realiza un dump de un descriptor de un TSS para conocer  sus valores</I>
<LI><A HREF="ver_tss.html">ver_tss</A> <I> Funcion que realiza un dump de la TSS que recibe como parametro  </I>
<LI><A HREF="verificar_raton.html">verificar_raton</A> <I> verificar_raton: verifica que exista un raton conectado al sistema  </I>
<LI><A HREF="wtoa.html">wtoa</A> <I> wtoa: transforma un word en ascii </I>
<LI><A HREF="wtoh.html">wtoh</A> <I> wtoh: transforma un word en ascii (formato hexa) </I>
<LI><A HREF="xchg_aprop.html">xchg_aprop</A> <I> xchg_aprop: api que realiza la llaamda a la system call que  alterna el modo de apriacion del procesador (apropiativo - no apropiativo)  </I>
</UL>
<H2>Variables</H2>
<UL>
<LI><A HREF="_gdt.html">_gdt</A> <I> Puntero a la GDT</I>
<LI><A HREF="_idt.html">_idt</A> <I> Puntero a la IDT (Interrupt Descriptor Table)</I>
<LI><A HREF="algoritmo_memoria.html">algoritmo_memoria</A> <I> tipo de algoritmo de memoria implementado</I>
<LI><A HREF="algoritmo_proceso.html">algoritmo_proceso</A> <I> Algoritmo de administracion de procesos</I>
<LI><A HREF="anterior.html">anterior</A> <I> Estructura que representa un nodo de la cola y que posee el contenido de un PCB y un puntero al siguiente nodo y uno al anterior y conformar asi una lista doblemente enlazada</I>
<LI><A HREF="apropiativo.2.html">apropiativo</A> <I> Modo de apropiacion  (0: no apropiativo - 1: apropiativo)</I>
<LI><A HREF="buffer_teclado.html">buffer_teclado</A> <I> Puntero al buffer de caracteres del teclado</I>
<LI><A HREF="contador.html">contador</A> <I> Contador para comparar con el QUANTUM</I>
<LI><A HREF="descs_ide.html">descs_ide</A> <I> Arreglo de descriptores de los 4 posibles dispositivos ide</I>
<LI><A HREF="direccion_fd_buffer.html">direccion_fd_buffer</A> <I> Direccion del buffer temporal donde se almacenan los datos leidos</I>
<LI><A HREF="eax.7.html">eax</A> <I> ; * get_esp: Funcion que se encarga de obtener el valor del stack pointer</I>
<LI><A HREF="fat.3.html">fat</A> <I> La tabla de FAT ( donde se encuentra la informacion de los clusters )</I>
<LI><A HREF="fd_buffer.html">fd_buffer</A> <I> El buffer donde se almacentan los datos leidos</I>
<LI><A HREF="fd_done.html">fd_done</A> <I> el estado de la disquetera (FDC)</I>
<LI><A HREF="flag_irq_ide.html">flag_irq_ide</A> <I> Este modulo se encarga de todo el manejo de los dispositivos IDE</I>
<LI><A HREF="indice_lectura.html">indice_lectura</A> <I> Indice por donde va escribiendo el teclado dentro del buffer</I>
<LI><A HREF="irq6.html">irq6</A> <I> Flag que indica si se disparo o no la IRQ6</I>
<LI><A HREF="lista_ready_fin.html">lista_ready_fin</A> <I> Puntero al final de la lista de procesos</I>
<LI><A HREF="lista_ready_inicio.5.html">lista_ready_inicio</A> <I> Puntero al inicio de la lista de procesos</I>
<LI><A HREF="motor_encendido.html">motor_encendido</A> <I> Flag que indica si el motor esta o no encendido</I>
<LI><A HREF="pcb_scheduler.3.html">pcb_scheduler</A> <I> PCB que representa el scheduler (necesitamos tenerla declarada para cuando hagamos el context switch desde el timer, IRQ0)</I>
<LI><A HREF="sector_booteo.html">sector_booteo</A> <I> El sector numero cero del disco (Bios Parameter Block)</I>
<LI><A HREF="semaforo_fdc.html">semaforo_fdc</A> <I> Flag que indica si hay un proceso leyendo el FDC ( se usa para apagar el motor del FDC unicamente cuando nadie lo usa )</I>
<LI><A HREF="siguiente_indice.html">siguiente_indice</A> <I> Indice de ubicacion de tareas dentro de la GDT</I>
<LI><A HREF="tarea_actual.11.html">tarea_actual</A> <I> Puntero a la tarea que esta ejecutando actualmente</I>
<LI><A HREF="ultima_posicion.html">ultima_posicion</A> <I> Indice de alocacion de memoria</I>
</UL>
<H2>Macros</H2>
<UL>
<LI><A HREF="CANT_DESCRIPT.html">CANT_DESCRIPT</A> <I> sodero/idt</I>
<LI><A HREF="DTR_EN_UNO.html">DTR_EN_UNO</A> <I> 0x6200 = 0110 0010 0000 0000 0x10B = 0001 0000 1011 0000 0000 0000 0000 0010 0000 0000 0010 0001 0000 0000 0000 0xC6 = 1100 0110</I>
<LI><A HREF="FDC_BASE.html">FDC_BASE</A> <I> Base del puerto del controlador de disquette</I>
<LI><A HREF="INTERFAZ.html">INTERFAZ</A> <I> Definicion del nombre del ejecutable del proceso Interfaz</I>
<LI><A HREF="LIMITE.html">LIMITE</A> <I> video</I>
<LI><A HREF="MEM_VIDEO.html">MEM_VIDEO</A> <I> Direccion de memoria de Video</I>
<LI><A HREF="NEGRO.html">NEGRO</A> <I> Constantes que representan los colores</I>
<LI><A HREF="NULL.html">NULL</A> <I> sodero/definiciones</I>
<LI><A HREF="POSICION.html">POSICION</A> <I> Devuelve la direccion de memoria para escribir un char en las coordenadas (x,y)</I>
<LI><A HREF="TAMANIO_PILA_USUARIO.html">TAMANIO_PILA_USUARIO</A> <I> Define del tamanio de la PILA que poseen los procesos de USUARIO = 4Kb</I>
<LI><A HREF="sti.html">sti</A> <I> sodero/registros</I>
<LI><A HREF="va_arg.html">va_arg</A> <I> Utilizada por imprimir(</I>
<LI><A HREF="va_end.html">va_end</A> <I> Utilizada por imprimir(</I>
<LI><A HREF="va_rounded_size.html">va_rounded_size</A> <I> Utilizada por imprimir(</I>
<LI><A HREF="va_start.html">va_start</A> <I> Utilizada por imprimir(</I>
</UL>
<H2>Definiciones de tipos</H2>
<UL>
<LI><A HREF="FIFO.html">FIFO</A> <I> Enum que identifica el tipo de algoritmo utilizado por el scheduler</I>
<LI><A HREF="PROCESO_USUARIO.html">PROCESO_USUARIO</A> <I> Enum para identificar un proceso es de usuario o de sistema</I>
<LI><A HREF="READY.html">READY</A> <I> Enum el estado de un proceso en un momento determinado</I>
<LI><A HREF="SEG_SISTEMA.html">SEG_SISTEMA</A> <I> Enum para identificar a un descriptor de segmento como de codigo, de datos, etc</I>
<LI><A HREF="back_link.html">back_link</A> <I> Un TSS: representa el estado de una tarea en un momento dado</I>
<LI><A HREF="desc_tss.html">desc_tss</A> <I> Esta union representa un descriptor (entrada) dentro de la GDT, debido a que la misma puede contener diferentes tipos de descriptores, sera necesario agregar a esta union todos dichos posibles tipos, entonces cuando se referencie una variable de tipo "descriptor" habra que tener en cuenta a que tipo de descriptor se esta referenciando, para ello hay que explicitarlo:  descriptor desc; desc</I>
<LI><A HREF="descriptores.html">descriptores</A> <I> Estructura que representa a la GDT propiamente dicha, la misma contiene un arreglo de 2^13 = 8192 posibles descriptores que puede tener seteada la GDT</I>
<LI><A HREF="ed.html">ed</A> <I> Estructura que representa un descriptor de Archivo</I>
<LI><A HREF="handler.html">handler</A> <I> El descriptor de una interrupcion</I>
<LI><A HREF="limite_0_15.html">limite_0_15</A> <I> Descriptor de un TSS: variable que 'vive' en la GDT y que referenciara a un TSS dado</I>
<LI><A HREF="offset_0_15.html">offset_0_15</A> <I> El descriptor de una int gate</I>
<LI><A HREF="reservado0.html">reservado0</A> <I> El descriptor de una task gate</I>
<LI><A HREF="sector_a_leer.html">sector_a_leer</A> <I> Estructura que representa la entrada de directorio actual</I>
<LI><A HREF="tarea.html">tarea</A> <I> Estructura que representa una PCB</I>
</UL>
<I><A HREF="HIER.html">Herencia de clases</A></I><P><HR>
<BR>
Esta pagina fue generada con la ayuda de <A HREF="http://www.imaginator.com/doc++">DOC++</A>.
</BODY>
